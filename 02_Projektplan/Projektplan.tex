\chapter{Projektplan}
\section{Projektübersicht}
Es soll eine generische API erstellt werden, um über ein 
Dashboard Services zu abonnieren, dabei können bei der API Vorlagen 
hinterlegt werden, welche mehrere Servicemodule beinhalten 
(Compute,Storage,Network).
Die API soll dabei möglichst modular aufgebaut sein, damit sie für verschiedenste
Kombinationen von Compute, Storage und Network einsetzbar ist.
\subsection{Zweck und Ziel}
 Gelerntes aus verschiedenen Modulen anwenden, sich mit der gestellten 
 Aufgabenstellung auseinandersetzen 
 und diese umsetzen.

\subsection{Primäre Features}
\begin{itemize}
  \item Generische API
  \item Workflow zum abonnieren/kündigen
  \item Unterstützung von mindestens 1 Compute Anbieter
  \item Unterstützung von mindestens 1 Storage Anbieter
  \item Unterstützung von mindestens 1 Network Anbieter
  \item Admin Dashboard um Services verwalten zu können
  \item simples User-Dashboard
\end{itemize}
\subsection{Erweiterte Features}
\begin{itemize}
  \item Admin-Dashboard um Funktionen erweitern
  \item Unterstützung für mehr Compute Anbieter
  \item Unterstützung für mehr Storage Anbieter
  \item Unterstützung für mehr Network Anbieter
\end{itemize}
\subsection{Lieferumfang}
\begin{itemize}
  \item Source-Code
  \item Source-Code Dokumentation
  \item Projektdokumentation
\end{itemize}

\subsection{Annahmen und Einschränkungen}
Die Applikation setzt sich aus einem Dashboard und einer generischen 
API/RESTful API
zusammen, die sollten dabei verteilt betrieben werden können.
Das User-Dashboard würde lediglich zum Testen der RESTful API verwendet.
Die generische API soll dabei so viele Anbieter wie möglich abdecken.
\section{Projektorganisation}
Wir setzen beim Project auf Scrum\autocite{scrum}, wodurch lediglich die Projektrollen Product 
Owner, Entwickler und Scrum-Master zur Verfügung stehen.
\subsection{Organisationsstruktur}
\begin{tikzpicture}[auto, node distance = 0.4cm, thick,
  every node/.style = {rectangle, font = \sffamily, white,
    top color = logocolor!90!black, bottom color = logocolor!60!black,
    text width = 4.5cm, align = center, minimum height = 1cm}]
  \node (PO) {\textbf{Beat Stettler} \\
      \vspace{0.2cm}
  \includegraphics[width=0.7\textwidth]{./02_Projektplan/images/stettler}
   \vspace{0.2cm}
  Product Owner};
  \coordinate [below = 3cm of PO] (Mitte);
  \node (Silvan) [left  = 2mm of Mitte]  {\textbf{Silvan Adrian} \\
    \vspace{0.2cm}
  \includegraphics[width=0.7\textwidth]{./02_Projektplan/images/silvan}
   \vspace{0.2cm}
Entwickler/Scrum Master};
  \node (Fabian) [right = 2mm of Mitte]  {\textbf{Fabian Binna} \\
  \vspace{0.2cm}
  \includegraphics[width=0.7\textwidth]{./02_Projektplan/images/fabian}
   \vspace{0.2cm}
 Entwickler};
  \draw [logocolor!60!black,thick]
    (PO)    -- (Mitte) -- (Silvan)
    (Fabian)   -- (Mitte); 
\end{tikzpicture}

\subsection{Externe Schnittstellen}
\textbf{Projektbetreuer:} \\
Beat Stettler (\href{mailto:Beat.Stettler@ins.hsr.ch}{Beat.Stettler@ins.hsr.ch})  
\\
Urs Baumann (\href{mailto:Urs.Baumann@ins.hsr.ch}{Urs.Baumann@ins.hsr.ch})


\section{Managment Abläufe}

\subsection{Kostenvoranschlag}
Gemäss Vorgaben wird mit ca.: 480 Stunden gerechnet.
\newline
\textbf{Gesamtaufwand:} ca.: 480 Stunden\\
\textbf{Aufwand pro Woche:} ca.:  34 Stunden\\
\textbf{Aufwand pro Woche pro Teammitglied:} ca.: \uline{17 Stunden}

\subsection{Planung}
\begin{tabularx}{\textwidth}{l X l l}
\textbf{Name} & \textbf{Beschreibung} & \textbf{Beginn} &  \textbf{Ende} \\
\hline
\pbox{3cm}{
\textbf{Analyse}
\\
\textbf{Anforderung}
\\
\textbf{Design} 
}& Analyse der vorhandenen APIs + Anforderungen 
erstellen + Design Grundlagen erstellen & 14.09.15 & 19.10.15\\
\hline
\textbf{Sprint 1} & Grundgerüst generische API, um Storage, Compute und Network 
abonnieren/kündigen zu können
+ Workflow abonnieren/löschen  & 19.10.15 & 02.11.15 \\
\hline
\textbf{Sprint 2} & Restful Interface für die API, um Services über HTTP 
abonnieren zu können + User-Dashboard (sehr spartanisch)  um Services 
abonnieren/kündigen zu können
& 02.11.15 & 23.11.15 \\
\hline
\textbf{Sprint 3} & Admin Dashboard, um Services verwalten 
und ihnen ein Konfigurationsdatei hinterlegen zu können & 23.11.15 & 07.12.15 \\
\hline
\textbf{Abschluss} & Studiengang Arbeit zur Abgabe vorbereiten + Präsentation 
vorbereiten & 07.12.15 & 18.12.15\\
\end{tabularx}

\subsection{Besprechungen}
Daily Meetings (ca. 10 - 15min) werden während der Pause oder über Skype stattfinden, um sich 
gegenseitig über Probleme oder abgeschlossene Arbeitspakete informieren zu können.
Nach jedem Abschluss eines Sprints wird ein Sprintreview durchgeführt, um zu prüfen 
ob alles gemäss Plan erledigt wurde + die aktuellste Version der Software 
released.
\section{Risikomanagement}
\subsection{Risiken}
\includepdf[pages=-]{./02_Projektplan/Initiales_Risikomanagement.pdf}
\subsection{Umgang mit Risiken}
Für die Risiken werden Reserven eingeplant. Die Reserven werden direkt in die einzelnen Tickets 
einberechnet. Falls Risiken eintreffen werden diese sofort an einem der Daily-Meetings kommuniziert 
und mögliche Lösungen evaluiert.
\section{Arbeitspakete}

Die Arbeitspakete werden in Open Project erstellt und gepflegt.
Lesender Zugriff ist anonym möglich, schreibender nur als Benutzer. 
\\
Link zur Open Project Instanz : \href{http://sddc.silvn.com}{http://sddc.silvn.com}

\section{Infrastruktur}

\subsection{Entwicklungsinfrastruktur}

\begin{tabularx}{\textwidth}{X X X X}
\textbf{Name} & \textbf{Hardware} & \textbf{Betriebssystem} & \textbf{IDE} \\
\hline
Silvan Adrian & MacBook Pro & OSX 10.10.5 &  Eclipse Mars \\
\hline
Fabian Binna & Lenovo T430s & Windows 10 &  Eclipse Mars\\
\hline
\end{tabularx}

\subsection{Tools/Software}
\begin{itemize}
    \item \textbf{BuildServer:} Travis-CI
    \item \textbf{Versionsmanagement:} GIT
    \item \textbf{Notifications:} Slack
    \item \textbf{Wireframing:} Pencil
    \item \textbf{Test Coverage:} Cobertura
    \item \textbf{Bugs Vorbeugung:} Findbugs
    \item \textbf{Metriken:} SonarQube
\end{itemize}

\subsection{Kommunikationsmittel}
\begin{itemize}
    \item E-Mail
    \item Skype
    \item Open Project
    \item GitHub
    \item Whatsapp
    \item Slack
\end{itemize}

\section{Qualitätsmassnahmen}
\subsection{Dokumentation}
Die Dokumentation befindet sich auf einem GitHub Repository 
(\href{https://github.com/hsr-sa-hs15-sddc/sa-doc}{sa-doc}).
Die Dokumentation wird in \LaTeX geschrieben.\\

\subsection{Projektmanagement}
Für das Projektmanagement wird OpenProject verwendet.\\
\\
\url{http://sddc.silvn.com}

\subsection{Metriken}
Für Metriken wird SonarQube verwendet.\\
\\
\url{http://sonar.silvn.com}

\subsection{Entwicklung}

\subsubsection{IDE}
Eclipse Mars\\

\subsubsection{Unit Testing / Test-Driven Development}
Die Unit Tests kommen in einen separaten Ordner "Test".
Es wird eine möglichst hohe Code Coverage angestrebt.
Die Code Coverage wird mit einem Tool sichergestellt.\\
\\
Die Klassen werden mit Hilfe von Test-Driven Development implementiert.

\subsubsection{Code Review}
Nach jedem Sprint oder bei Abschluss grosser Arbeitspakete wird ein Code Review durchgeführt.\\
\\
Die Review Protokolle werden auf dem GitHub Repository \href{https://github.com/hsr-sa-hs15-sddc/sa-doc}{sa-doc}
 abgelegt.

\subsubsection{Logging}
Für das Logging wird log4j verwendet.\\
\\
TRACE: Ausführliches Debugging\\
DEBUG: allgemeines Debugging\\
INFO: allgemeine Informationen\\
WARN: Auftreten einer unerwarteten Situation\\
ERROR: Fehler\\
FATAL: Kritischer Fehler\\
\\

\subsubsection{Metrikanalyse}
Die Metriken werden nach jedem Sprint protokolliert und Analysiert. 
Die Metriken helfen während einem Code-Review auf problematische 
Code Stücke hinzuweisen. Sie können auch beim Debuggen hilfreich sein.


\subsection{Testen}

\subsection{Modultest}
Die Modultests werden, wie schon beschrieben ,während der Entwicklung mit Test-Driven Development erstellt.
Zu jedem Modul werden Tests geschrieben, um eine möglichst hohe Code 
Coverage zu erreichen.
Die Tests werden nochmals auf dem Build Server ausgeführt um ``it 
works on my machine'' abzudecken.\\

Produkte:
\begin{itemize}
\item JUnit Tester
\item Travis
\item SonarQube Analyse
\end{itemize}

\subsection{Integrationstest}
Bei den Integrationstests kommt eine Kombination aus automatisierten Tests, 
sowie eine Analyse des Ablaufs zum Einsatz.
Die Tests werden an verschiedenen Schichten angesetzt (Presentation und Business-Layer). 
Die Unteren Schichten, die für den Integrationstest nicht relevant sind werden gemockt. \\

Produkte:
\begin{itemize}
\item JUnit Tester
\item Log-Daten
\end{itemize}

\subsection{Systemtest}
Die Systemtests richten sich nach den User Stories und deren Akzeptanzkriterien. 
Die Kriterien werden von einem Tester nach 
Protokollangaben getestet und dokumentiert. Auch hier können Log-Daten eine Hilfe für die Analyse sein.

Systemtests werden nach jedem Sprint durchgeführt um die geplante Funktionalität 
zu testen und so die neuste Version der Software releasen zu können.\\

Produkte:
\begin{itemize}
\item Protokoll
\item Log-Daten
\end{itemize}

\subsection{Abnahmetest}
Der Abnahmetest wird vom Kunden selbst durchgeführt.
